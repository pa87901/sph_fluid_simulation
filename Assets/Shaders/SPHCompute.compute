#pragma kernel Integrate // Use the force of each particle to move particle.
#pragma kernel ComputeForces // Compute forces for each particle.
#pragma kernel ComputeDensityPressure // Compute density/pressure for each particle.

struct Particle {
    float pressure;
    float density;
    float3 currentForce;
    float3 velocity;
    float3 position;
};

RWStructuredBuffer<Particle> _particles;

float particleMass;
float viscosity;
float gasConstant;
float restDensity;
float boundDamping;
float radius;
float radius2;
float radius3;
float radius4;
float radius5;
float pi;
int particleLength;
float timestep;
float3 boxSize;

[numthreads(100,1,1)]
void Integrate (uint3 id: SV_DISPATCHTHREADID) {
    _particles[id.x].currentForce = float3(0, (-9.81 * particleMass), 0);

    // Next tow lines is basically F = ma.
    float3 vel = _particles[id.x].velocity + ((_particles[id.x].currentForce/particleMass) * timestep);
    _particles[id.x].position += vel * timestep;

    float3 topRight = boxSize / 2;
    float3 bottomLeft = -boxSize/2;

    // Min boundary enforcements.
    if (_particles[id.x].position.x - radius < bottomLeft.x) {
       vel.x *= boundDamping;
        _particles[id.x].position.x = bottomLeft.x + radius;
    }

    if (_particles[id.x].position.y - radius < bottomLeft.y) {
       vel.y *= boundDamping;
        _particles[id.x].position.y = bottomLeft.y + radius;
    }

    if (_particles[id.x].position.z - radius < bottomLeft.z) {
       vel.z *= boundDamping;
        _particles[id.x].position.z = bottomLeft.z + radius;
    }

    // Max boundary enforcements.
    if (_particles[id.x].position.x + radius > topRight.x) {
       vel.x *= boundDamping;
        _particles[id.x].position.x = topRight.x - radius;
    }

    if (_particles[id.x].position.y + radius > topRight.y) {
       vel.y *= boundDamping;
        _particles[id.x].position.y = topRight.y - radius;
    }

    if (_particles[id.x].position.z + radius > topRight.z) {
       vel.z *= boundDamping;
        _particles[id.x].position.z = topRight.z - radius;
    }

    _particles[id.x].velocity = vel;
}

float StdKernel(float distanceSquared) {
    float x = 1.0f - distanceSquared / radius2;
    return 315.f / ( 64.f * pi * radius3 ) * x * x * x; // Poly kernel.
}

[numthreads(100, 1, 1)]
void ComputeDensityPressure(uint3 id: SV_DISPATCHTHREADID) {
    float3 origin = _particles[id.x].position;
    float sum = 0;
    
    for (int i = 0; i < particleLength; i++) {
        float3 diff = origin - _particles[i].position;
        float distanceSquared = dot(diff, diff);
        
        if (radius2 * 0.004 > distanceSquared * 0.004) {
            sum += StdKernel(distanceSquared * 0.004); // Apply smoothing kernel.
        } 
    }
    
    _particles[id.x].density = sum * particleMass + 0.000001f;
    _particles[id.x].pressure = gasConstant * (_particles[id.x].density - restDensity);
}